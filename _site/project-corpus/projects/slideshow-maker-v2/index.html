<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Slideshow Maker v2 — Project</title>
    <meta name="description" content="Command‑line media pipeline that compresses images, randomizes order, and builds a 1080p slideshow with music using FFmpeg." />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="/project-corpus/assets-styles.css" />
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a href="/project-corpus/" style="text-decoration:none;color:var(--muted)">← Back to all projects</a>
        <h1 class="project-title">Slideshow Maker v2</h1>
        <p class="project-subtitle">Command‑line media pipeline that compresses images, randomizes order, and builds a 1080p slideshow with music using FFmpeg.</p>
      </div>
    </header>
    <main class="container project-main">
      <section class="project-content">
        <div class="hero">
          <img src="/project-corpus/placeholder.svg" alt="Placeholder cover for Slideshow Maker v2" />
        </div>

        <h2>Problem</h2>
        <p>
          Creating a polished video slideshow from a large, mixed set of photos and songs is tedious.
          Typical workflows involve resizing images, normalizing orientations, converting formats, shuffling order,
          calculating per‑slide timing from audio length, and hand‑authoring long FFmpeg commands.
          Slideshow Maker v2 merges those steps into one reliable, cross‑platform CLI pipeline.
        </p>

        <h2>Approach</h2>
        <p>
          The pipeline runs three deterministic stages: compress + normalize images to WebP, randomize filenames to
          establish a shuffled order (with an optional pinned first image), then assemble a 1080p/24fps slideshow with
          one or more audio tracks. Durations are computed from the audio using <code>ffprobe</code>; multiple tracks are
          blended with precise offsets and a configurable crossfade.
        </p>

        <h3>Architecture</h3>
        <ul>
          <li>
            Image pipeline — Reads from <code>assets/images_in/</code>, applies EXIF orientation via
            <code>ImageOps.exif_transpose</code>, converts non‑RGB to RGB (flattening alpha to white), resizes with
            LANCZOS down to max 1920px, and writes <code>.webp</code> (quality 85) into a temp workspace using a
            <code>ThreadPoolExecutor</code>.
          </li>
          <li>
            Order control — Randomizes filenames with cryptographically secure tokens while preserving a special
            <code>0000.webp</code> opener if present, so you can guarantee the first slide.
          </li>
          <li>
            Video assembly — Builds a compact <code>-filter_complex_script</code> that, for each image, scales with
            <code>force_original_aspect_ratio=decrease</code>, pads to 1920×1080, sets <code>sar=1</code>, and unifies
            <code>fps=24</code>; then concatenates all video segments.
          </li>
          <li>
            Audio mixing — Uses <code>ffprobe</code> to derive durations, subtracts the crossfade overlap, applies
            <code>adelay</code> per track, and mixes with <code>amix</code> (default crossfade: 4s). Single‑track audio is
            passed through.
          </li>
          <li>
            Encoding choices — <code>libx264</code> at <code>-crf 23</code>, <code>yuv420p</code> pixel format for broad
            compatibility, and AAC 192 kbps audio; avoids Windows command‑length limits by writing the filter graph to a
            temporary script file.
          </li>
          <li>
            Reliability — Verifies local FFmpeg/ffprobe binaries, creates and cleans a system temp directory, avoids
            random‑name collisions, and surfaces progress with <code>tqdm</code>.
          </li>
        </ul>

        <h3>Stack</h3>
        <ul>
          <li>Python 3.12 — Core runtime and CLI.</li>
          <li>Pillow — Image processing, EXIF transpose, resizing, WebP saves.</li>
          <li>pillow‑heif — HEIC/HEIF decoding via registered opener (optional but recommended).</li>
          <li>TQDM — Parallel progress bars for compression and renaming.</li>
          <li>FFmpeg/ffprobe — Video assembly, probing durations, mixing audio.</li>
          <li>uv + venv — Simple, reproducible environment setup.</li>
        </ul>

        <h3>Challenges</h3>
        <ul>
          <li>HEIC/HEIF support — Solved by registering <code>pillow_heif</code>; prints a warning if not available.</li>
          <li>Mixed orientations/aspects — Fixed with EXIF transpose and scale‑then‑pad to 16:9, <code>sar=1</code>.</li>
          <li>Long FFmpeg command lines — Avoided by using <code>-filter_complex_script</code> written to disk.</li>
          <li>Many images performance — Threaded compression with LANCZOS; minimal copies and temp workspace.</li>
          <li>Multi‑track music — Accurate timing via <code>ffprobe</code>, <code>adelay</code> offsets, and <code>amix</code>
            with a clean 4s crossfade.</li>
        </ul>

        <h2>Outcomes</h2>
        <p>
          A single command transforms a folder of photos and songs into a clean 1080p slideshow at 24 fps, with uniform
          framing and seamless audio. WebP compression keeps inputs light without visible quality loss for slideshow use.
          The design is robust for large batches and repeatable from project to project.
        </p>

        <h2>Usage</h2>
        <p>Place inputs and run the script:</p>
        <pre><code>assets/
  images_in/   # your photos (JPG, PNG, HEIC, ...)
  music_in/    # one or more songs (MP3, WAV, ...)
ffmpeg_bin/    # ffmpeg & ffprobe binaries
output/

python main.py

# Result: output/final_slideshow.mp4
</code></pre>
        <p>
          Tip: Add an image named <code>0000.jpg</code> (or any supported format) to pin it as the first slide. The
          compressor preserves that name as <code>0000.webp</code> and keeps it ahead of the randomized set.
        </p>

        <section class="updates">
          <h2>Updates</h2>
          
          
          
            <p>No updates yet.</p>
          
        </section>
      </section>
      <aside class="project-aside">
        <dl class="facts">
          <dt>Status</dt>
          <dd><span class="badge status active">Active</span></dd>
          <dt>Tags</dt>
          <dd>Python, FFmpeg, Pillow, CLI, Media</dd>
          <dt>Started</dt>
          <dd>Sep 2025</dd>
          <dt>Links</dt>
          <dd>
            <ul>
              <li><a href="#">Live demo</a></li>
              <li><a href="#">GitHub</a></li>
            </ul>
          </dd>
        </dl>
      </aside>
    </main>
    <footer class="site-footer">
      <div class="container">
        <small>© 2025 Adam Bandel</small>
      </div>
    </footer>
  </body>
  </html>

